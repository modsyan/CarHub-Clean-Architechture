//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import followIfLoginRedirect from './components/api-authorization/followIfLoginRedirect';

export class AuthenticationDevClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param registration (optional) 
     */
    postApiAuthenticationDevRegister(accept_Language: AcceptLanguage | undefined, registration: RegisterRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registration);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApiAuthenticationDevRegister(_response);
        });
    }

    protected processPostApiAuthenticationDevRegister(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param useCookies (optional) 
     * @param useSessionCookies (optional) 
     * @param accept_Language (optional) Language preference for the response.
     * @param login (optional) 
     */
    postApiAuthenticationDevLogin(useCookies: boolean | null | undefined, useSessionCookies: boolean | null | undefined, accept_Language: AcceptLanguage2 | undefined, login: LoginRequest | undefined): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/login?";
        if (useCookies !== undefined && useCookies !== null)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies !== undefined && useSessionCookies !== null)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApiAuthenticationDevLogin(_response);
        });
    }

    protected processPostApiAuthenticationDevLogin(response: Response): Promise<AccessTokenResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param refreshRequest (optional) 
     */
    postApiAuthenticationDevRefresh(accept_Language: AcceptLanguage3 | undefined, refreshRequest: RefreshRequest | undefined): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApiAuthenticationDevRefresh(_response);
        });
    }

    protected processPostApiAuthenticationDevRefresh(response: Response): Promise<AccessTokenResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param code (optional) 
     * @param changedEmail (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getApiAuthenticationDevConfirmEmail(userId: string | null | undefined, code: string | null | undefined, changedEmail: string | null | undefined, accept_Language: AcceptLanguage4 | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/confirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail !== undefined && changedEmail !== null)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApiAuthenticationDevConfirmEmail(_response);
        });
    }

    protected processGetApiAuthenticationDevConfirmEmail(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param resendRequest (optional) 
     */
    postApiAuthenticationDevResendConfirmationEmail(accept_Language: AcceptLanguage5 | undefined, resendRequest: ResendConfirmationEmailRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApiAuthenticationDevResendConfirmationEmail(_response);
        });
    }

    protected processPostApiAuthenticationDevResendConfirmationEmail(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param resetRequest (optional) 
     */
    postApiAuthenticationDevForgotPassword(accept_Language: AcceptLanguage6 | undefined, resetRequest: ForgotPasswordRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApiAuthenticationDevForgotPassword(_response);
        });
    }

    protected processPostApiAuthenticationDevForgotPassword(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param resetRequest (optional) 
     */
    postApiAuthenticationDevResetPassword(accept_Language: AcceptLanguage7 | undefined, resetRequest: ResetPasswordRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApiAuthenticationDevResetPassword(_response);
        });
    }

    protected processPostApiAuthenticationDevResetPassword(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param tfaRequest (optional) 
     */
    postApiAuthenticationDevManage2fa(accept_Language: AcceptLanguage8 | undefined, tfaRequest: TwoFactorRequest | undefined): Promise<TwoFactorResponse> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tfaRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApiAuthenticationDevManage2fa(_response);
        });
    }

    protected processPostApiAuthenticationDevManage2fa(response: Response): Promise<TwoFactorResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TwoFactorResponse>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getApiAuthenticationDevManageInfo(accept_Language: AcceptLanguage9 | undefined): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApiAuthenticationDevManageInfo(_response);
        });
    }

    protected processGetApiAuthenticationDevManageInfo(response: Response): Promise<InfoResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param infoRequest (optional) 
     */
    postApiAuthenticationDevManageInfo(accept_Language: AcceptLanguage10 | undefined, infoRequest: InfoRequest | undefined): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/api/AuthenticationDev/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(infoRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApiAuthenticationDevManageInfo(_response);
        });
    }

    protected processPostApiAuthenticationDevManageInfo(response: Response): Promise<InfoResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }
}

export class BrokersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param searchString (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getBrokers(pageNumber: number | undefined, pageSize: number | undefined, searchString: string | undefined, accept_Language: AcceptLanguage11 | undefined): Promise<BrokerVm> {
        let url_ = this.baseUrl + "/api/Brokers?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBrokers(_response);
        });
    }

    protected processGetBrokers(response: Response): Promise<BrokerVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrokerVm.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BrokerVm>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param profilePicture (optional) 
     */
    createBroker(name: string | null, username: string | null, email: string | null, phoneNumber: string | null, nationalId: string | null, accept_Language: AcceptLanguage12 | undefined, profilePicture: FileParameter | null | undefined): Promise<BrokerDto> {
        let url_ = this.baseUrl + "/api/Brokers?";
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else if(name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (username === undefined)
            throw new Error("The parameter 'username' must be defined.");
        else if(username !== null)
            url_ += "Username=" + encodeURIComponent("" + username) + "&";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (phoneNumber === undefined)
            throw new Error("The parameter 'phoneNumber' must be defined.");
        else if(phoneNumber !== null)
            url_ += "PhoneNumber=" + encodeURIComponent("" + phoneNumber) + "&";
        if (nationalId === undefined)
            throw new Error("The parameter 'nationalId' must be defined.");
        else if(nationalId !== null)
            url_ += "NationalId=" + encodeURIComponent("" + nationalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (profilePicture !== null && profilePicture !== undefined)
            content_.append("ProfilePicture", profilePicture.data, profilePicture.fileName ? profilePicture.fileName : "ProfilePicture");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateBroker(_response);
        });
    }

    protected processCreateBroker(response: Response): Promise<BrokerDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = BrokerDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BrokerDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getBroker(id: string, accept_Language: AcceptLanguage13 | undefined): Promise<BrokerDto> {
        let url_ = this.baseUrl + "/api/Brokers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBroker(_response);
        });
    }

    protected processGetBroker(response: Response): Promise<BrokerDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrokerDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BrokerDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    editBroker(id: string, accept_Language: AcceptLanguage14 | undefined, command: EditBrokerCommand): Promise<BrokerDto> {
        let url_ = this.baseUrl + "/api/Brokers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditBroker(_response);
        });
    }

    protected processEditBroker(response: Response): Promise<BrokerDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrokerDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BrokerDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteBroker(id: string, accept_Language: AcceptLanguage15 | undefined): Promise<BrokerDto> {
        let url_ = this.baseUrl + "/api/Brokers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteBroker(_response);
        });
    }

    protected processDeleteBroker(response: Response): Promise<BrokerDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BrokerDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BrokerDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getApiBrokersTest(accept_Language: AcceptLanguage16 | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Brokers/Test";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApiBrokersTest(_response);
        });
    }

    protected processGetApiBrokersTest(response: Response): Promise<string> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class CarsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param searchString (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getCars(pageNumber: number | undefined, pageSize: number | undefined, searchString: string | undefined, accept_Language: AcceptLanguage17 | undefined): Promise<CarVm> {
        let url_ = this.baseUrl + "/api/Cars?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCars(_response);
        });
    }

    protected processGetCars(response: Response): Promise<CarVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarVm.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarVm>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getCarDetails(id: string, accept_Language: AcceptLanguage18 | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Cars/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCarDetails(_response);
        });
    }

    protected processGetCarDetails(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    editCar(id: string, accept_Language: AcceptLanguage19 | undefined, command: EditCarCommand): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Cars/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditCar(_response);
        });
    }

    protected processEditCar(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteCar(id: string, accept_Language: AcceptLanguage20 | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Cars/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCar(_response);
        });
    }

    protected processDeleteCar(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }
}

export class DocumentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param files (optional) 
     */
    createDocument(carId: string, title: string, accept_Language: AcceptLanguage21 | undefined, files: FileParameter | null | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Documents?";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined and cannot be null.");
        else
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        if (title === undefined || title === null)
            throw new Error("The parameter 'title' must be defined and cannot be null.");
        else
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            content_.append("files", files.data, files.fileName ? files.fileName : "files");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDocument(_response);
        });
    }

    protected processCreateDocument(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CarDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }

    /**
     * @param title (optional) 
     * @param accept_Language (optional) Language preference for the response.
     * @param file (optional) 
     */
    editDocument(id: string, title: string | null | undefined, accept_Language: AcceptLanguage22 | undefined, file: FileParameter | null | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Documents/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditDocument(_response);
        });
    }

    protected processEditDocument(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteDocument(id: string, accept_Language: AcceptLanguage23 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Documents/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDocument(_response);
        });
    }

    protected processDeleteDocument(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param files (optional) 
     */
    createManyDocuments(carId: string, titles: string[], accept_Language: AcceptLanguage24 | undefined, files: any[] | null | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Documents/List?";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined and cannot be null.");
        else
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        if (titles === undefined || titles === null)
            throw new Error("The parameter 'titles' must be defined and cannot be null.");
        else
            titles && titles.forEach(item => { url_ += "titles=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.toString()));

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateManyDocuments(_response);
        });
    }

    protected processCreateManyDocuments(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CarDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteManyDocuments(documentIds: string[], accept_Language: AcceptLanguage25 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Documents/List?";
        if (documentIds === undefined || documentIds === null)
            throw new Error("The parameter 'documentIds' must be defined and cannot be null.");
        else
            documentIds && documentIds.forEach(item => { url_ += "documentIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteManyDocuments(_response);
        });
    }

    protected processDeleteManyDocuments(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param carId (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getDocumentsFromTrash(carId: string | null | undefined, accept_Language: AcceptLanguage26 | undefined): Promise<PaginatedListOfDocumentDto> {
        let url_ = this.baseUrl + "/api/Documents/Trash?";
        if (carId !== undefined && carId !== null)
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDocumentsFromTrash(_response);
        });
    }

    protected processGetDocumentsFromTrash(response: Response): Promise<PaginatedListOfDocumentDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfDocumentDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfDocumentDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    restoreDocumentFromTrash(id: string, accept_Language: AcceptLanguage27 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Documents/Trash/Restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestoreDocumentFromTrash(_response);
        });
    }

    protected processRestoreDocumentFromTrash(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    emptyDocumentTrash(carId: string, accept_Language: AcceptLanguage28 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Documents/Trash/Delete?";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined and cannot be null.");
        else
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmptyDocumentTrash(_response);
        });
    }

    protected processEmptyDocumentTrash(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteDocumentPermanently(id: string, accept_Language: AcceptLanguage29 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Documents/Trash/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDocumentPermanently(_response);
        });
    }

    protected processDeleteDocumentPermanently(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class InspectionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param file (optional) 
     */
    createInspection(carId: string, title: string, accept_Language: AcceptLanguage30 | undefined, file: FileParameter | null | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Inspections?";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined and cannot be null.");
        else
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        if (title === undefined || title === null)
            throw new Error("The parameter 'title' must be defined and cannot be null.");
        else
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateInspection(_response);
        });
    }

    protected processCreateInspection(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CarDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }

    /**
     * @param title (optional) 
     * @param accept_Language (optional) Language preference for the response.
     * @param file (optional) 
     */
    editInspection(id: string, title: string | null | undefined, accept_Language: AcceptLanguage31 | undefined, file: FileParameter | null | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Inspections/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (title !== undefined && title !== null)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditInspection(_response);
        });
    }

    protected processEditInspection(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteInspection(id: string, accept_Language: AcceptLanguage32 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Inspections/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInspection(_response);
        });
    }

    protected processDeleteInspection(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     * @param files (optional) 
     */
    createManyInspections(carId: string, titles: string[], accept_Language: AcceptLanguage33 | undefined, files: any[] | null | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Inspections/List?";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined and cannot be null.");
        else
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        if (titles === undefined || titles === null)
            throw new Error("The parameter 'titles' must be defined and cannot be null.");
        else
            titles && titles.forEach(item => { url_ += "titles=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.toString()));

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateManyInspections(_response);
        });
    }

    protected processCreateManyInspections(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CarDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteManyInspections(inspectionIds: string[], accept_Language: AcceptLanguage34 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Inspections/List?";
        if (inspectionIds === undefined || inspectionIds === null)
            throw new Error("The parameter 'inspectionIds' must be defined and cannot be null.");
        else
            inspectionIds && inspectionIds.forEach(item => { url_ += "inspectionIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteManyInspections(_response);
        });
    }

    protected processDeleteManyInspections(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param carId (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getInspectionsFromTrash(carId: string | null | undefined, accept_Language: AcceptLanguage35 | undefined): Promise<PaginatedListOfInspectionDto> {
        let url_ = this.baseUrl + "/api/Inspections/Trash?";
        if (carId !== undefined && carId !== null)
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInspectionsFromTrash(_response);
        });
    }

    protected processGetInspectionsFromTrash(response: Response): Promise<PaginatedListOfInspectionDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfInspectionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfInspectionDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    restoreInspectionsFromTrash(id: string, accept_Language: AcceptLanguage36 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Inspections/Trash/Restore/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestoreInspectionsFromTrash(_response);
        });
    }

    protected processRestoreInspectionsFromTrash(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    emptyInspectionTrash(carId: string, accept_Language: AcceptLanguage37 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Inspections/Trash/Delete?";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined and cannot be null.");
        else
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEmptyInspectionTrash(_response);
        });
    }

    protected processEmptyInspectionTrash(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteInspectionPermanently(id: string, accept_Language: AcceptLanguage38 | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Inspections/Trash/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInspectionPermanently(_response);
        });
    }

    protected processDeleteInspectionPermanently(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class LookupsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getColors(accept_Language: AcceptLanguage39 | undefined): Promise<ColorVm> {
        let url_ = this.baseUrl + "/api/Lookups/colors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetColors(_response);
        });
    }

    protected processGetColors(response: Response): Promise<ColorVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ColorVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ColorVm>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param searchString (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getMakes(pageNumber: number | null | undefined, pageSize: number | null | undefined, searchString: string | null | undefined, accept_Language: AcceptLanguage40 | undefined): Promise<MakeVm> {
        let url_ = this.baseUrl + "/api/Lookups/makes?";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchString !== undefined && searchString !== null)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMakes(_response);
        });
    }

    protected processGetMakes(response: Response): Promise<MakeVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MakeVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MakeVm>(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param searchString (optional) 
     * @param makeId (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getModels(pageNumber: number | null | undefined, pageSize: number | null | undefined, searchString: string | null | undefined, makeId: number | null | undefined, accept_Language: AcceptLanguage41 | undefined): Promise<ModelVm> {
        let url_ = this.baseUrl + "/api/Lookups/models?";
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchString !== undefined && searchString !== null)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        if (makeId !== undefined && makeId !== null)
            url_ += "makeId=" + encodeURIComponent("" + makeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModels(_response);
        });
    }

    protected processGetModels(response: Response): Promise<ModelVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModelVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModelVm>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getOverall(accept_Language: AcceptLanguage42 | undefined): Promise<OverallDto> {
        let url_ = this.baseUrl + "/api/Lookups/overall";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOverall(_response);
        });
    }

    protected processGetOverall(response: Response): Promise<OverallDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OverallDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OverallDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getRoles(accept_Language: AcceptLanguage43 | undefined): Promise<RoleVm> {
        let url_ = this.baseUrl + "/api/Lookups/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: Response): Promise<RoleVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleVm>(null as any);
    }
}

export class OrdersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param searchString (optional) 
     * @param sortBy (optional) 
     * @param sortOrder (optional) 
     * @param isCompletedOnly (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getOrders(pageNumber: number | undefined, pageSize: number | undefined, searchString: string | undefined, sortBy: string | undefined, sortOrder: string | undefined, isCompletedOnly: boolean | undefined, accept_Language: AcceptLanguage44 | undefined): Promise<OrderVm> {
        let url_ = this.baseUrl + "/api/Orders?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "sortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        if (isCompletedOnly === null)
            throw new Error("The parameter 'isCompletedOnly' cannot be null.");
        else if (isCompletedOnly !== undefined)
            url_ += "isCompletedOnly=" + encodeURIComponent("" + isCompletedOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrders(_response);
        });
    }

    protected processGetOrders(response: Response): Promise<OrderVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderVm.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderVm>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    launchOrder(modelId: number, year: number, colorId: number, isBroker: boolean, userFullName: string | null, userNationalityId: string | null, releasedAfterInMonths: number, accept_Language: AcceptLanguage45 | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Orders?";
        if (modelId === undefined || modelId === null)
            throw new Error("The parameter 'modelId' must be defined and cannot be null.");
        else
            url_ += "ModelId=" + encodeURIComponent("" + modelId) + "&";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined and cannot be null.");
        else
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        if (colorId === undefined || colorId === null)
            throw new Error("The parameter 'colorId' must be defined and cannot be null.");
        else
            url_ += "ColorId=" + encodeURIComponent("" + colorId) + "&";
        if (isBroker === undefined || isBroker === null)
            throw new Error("The parameter 'isBroker' must be defined and cannot be null.");
        else
            url_ += "IsBroker=" + encodeURIComponent("" + isBroker) + "&";
        if (userFullName === undefined)
            throw new Error("The parameter 'userFullName' must be defined.");
        else if(userFullName !== null)
            url_ += "UserFullName=" + encodeURIComponent("" + userFullName) + "&";
        if (userNationalityId === undefined)
            throw new Error("The parameter 'userNationalityId' must be defined.");
        else if(userNationalityId !== null)
            url_ += "UserNationalityId=" + encodeURIComponent("" + userNationalityId) + "&";
        if (releasedAfterInMonths === undefined || releasedAfterInMonths === null)
            throw new Error("The parameter 'releasedAfterInMonths' must be defined and cannot be null.");
        else
            url_ += "ReleasedAfterInMonths=" + encodeURIComponent("" + releasedAfterInMonths) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLaunchOrder(_response);
        });
    }

    protected processLaunchOrder(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CarDto.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getOrderDetails(id: string, accept_Language: AcceptLanguage46 | undefined): Promise<OrderDto> {
        let url_ = this.baseUrl + "/api/Orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrderDetails(_response);
        });
    }

    protected processGetOrderDetails(response: Response): Promise<OrderDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    completeOrder(id: string, accept_Language: AcceptLanguage47 | undefined): Promise<CarDto> {
        let url_ = this.baseUrl + "/api/Orders/complete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteOrder(_response);
        });
    }

    protected processCompleteOrder(response: Response): Promise<CarDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CarDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CarDto>(null as any);
    }
}

export class OwnersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getOwners(accept_Language: AcceptLanguage48 | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Owners";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOwners(_response);
        });
    }

    protected processGetOwners(response: Response): Promise<string> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class ParkingSlotsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getParkingSlots(pageNumber: number | undefined, pageSize: number | undefined, accept_Language: AcceptLanguage49 | undefined): Promise<PaginatedListOfParkingSlotDto> {
        let url_ = this.baseUrl + "/api/ParkingSlots?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetParkingSlots(_response);
        });
    }

    protected processGetParkingSlots(response: Response): Promise<PaginatedListOfParkingSlotDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfParkingSlotDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfParkingSlotDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    addParkingSlot(name: string, capacity: number, description: string, accept_Language: AcceptLanguage50 | undefined): Promise<ParkingSlotDto> {
        let url_ = this.baseUrl + "/api/ParkingSlots?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (capacity === undefined || capacity === null)
            throw new Error("The parameter 'capacity' must be defined and cannot be null.");
        else
            url_ += "capacity=" + encodeURIComponent("" + capacity) + "&";
        if (description === undefined || description === null)
            throw new Error("The parameter 'description' must be defined and cannot be null.");
        else
            url_ += "description=" + encodeURIComponent("" + description) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddParkingSlot(_response);
        });
    }

    protected processAddParkingSlot(response: Response): Promise<ParkingSlotDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ParkingSlotDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParkingSlotDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getParkingSlotDetails(id: number, accept_Language: AcceptLanguage51 | undefined): Promise<ParkingSlotDto> {
        let url_ = this.baseUrl + "/api/ParkingSlots/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetParkingSlotDetails(_response);
        });
    }

    protected processGetParkingSlotDetails(response: Response): Promise<ParkingSlotDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParkingSlotDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParkingSlotDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    editParkingSlot(id: number, accept_Language: AcceptLanguage52 | undefined, command: EditParkingSlotCommand): Promise<ParkingSlotDto> {
        let url_ = this.baseUrl + "/api/ParkingSlots/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditParkingSlot(_response);
        });
    }

    protected processEditParkingSlot(response: Response): Promise<ParkingSlotDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParkingSlotDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParkingSlotDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteParkingSlot(id: number, accept_Language: AcceptLanguage53 | undefined): Promise<ParkingSlotDto> {
        let url_ = this.baseUrl + "/api/ParkingSlots/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteParkingSlot(_response);
        });
    }

    protected processDeleteParkingSlot(response: Response): Promise<ParkingSlotDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParkingSlotDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParkingSlotDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    addCarToSlot(id: number, carId: string, accept_Language: AcceptLanguage54 | undefined): Promise<ParkingSlotDto> {
        let url_ = this.baseUrl + "/api/ParkingSlots/{id}/cars?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined and cannot be null.");
        else
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddCarToSlot(_response);
        });
    }

    protected processAddCarToSlot(response: Response): Promise<ParkingSlotDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParkingSlotDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParkingSlotDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    removeCarFromSlot(carId: string, accept_Language: AcceptLanguage55 | undefined): Promise<ParkingSlotDto> {
        let url_ = this.baseUrl + "/api/ParkingSlots/cars/{carId}";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined.");
        url_ = url_.replace("{carId}", encodeURIComponent("" + carId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveCarFromSlot(_response);
        });
    }

    protected processRemoveCarFromSlot(response: Response): Promise<ParkingSlotDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParkingSlotDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ParkingSlotDto>(null as any);
    }
}

export class ReleasingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getReleasedCars(accept_Language: AcceptLanguage56 | undefined): Promise<ReleaseVm> {
        let url_ = this.baseUrl + "/api/Releasing";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReleasedCars(_response);
        });
    }

    protected processGetReleasedCars(response: Response): Promise<ReleaseVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReleaseVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReleaseVm>(null as any);
    }

    /**
     * @param releaseDate (optional) 
     * @param accept_Language (optional) Language preference for the response.
     * @param documents (optional) 
     */
    releaseCar(carId: string, releaseDate: Date | null | undefined, accept_Language: AcceptLanguage57 | undefined, documents: FileParameter | null | undefined): Promise<ReleaseDto> {
        let url_ = this.baseUrl + "/api/Releasing?";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined and cannot be null.");
        else
            url_ += "carId=" + encodeURIComponent("" + carId) + "&";
        if (releaseDate !== undefined && releaseDate !== null)
            url_ += "releaseDate=" + encodeURIComponent(releaseDate ? "" + releaseDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (documents !== null && documents !== undefined)
            content_.append("documents", documents.data, documents.fileName ? documents.fileName : "documents");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReleaseCar(_response);
        });
    }

    protected processReleaseCar(response: Response): Promise<ReleaseDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ReleaseDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReleaseDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getReleasedCarDetails(carId: string, accept_Language: AcceptLanguage58 | undefined): Promise<ReleaseDto> {
        let url_ = this.baseUrl + "/api/Releasing/{carId}";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined.");
        url_ = url_.replace("{carId}", encodeURIComponent("" + carId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReleasedCarDetails(_response);
        });
    }

    protected processGetReleasedCarDetails(response: Response): Promise<ReleaseDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReleaseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReleaseDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    editRelease(carId: string, accept_Language: AcceptLanguage59 | undefined, command: EditReleaseCommand): Promise<ReleaseDto> {
        let url_ = this.baseUrl + "/api/Releasing/{carId}";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined.");
        url_ = url_.replace("{carId}", encodeURIComponent("" + carId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditRelease(_response);
        });
    }

    protected processEditRelease(response: Response): Promise<ReleaseDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReleaseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReleaseDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    deleteRelease(carId: string, accept_Language: AcceptLanguage60 | undefined): Promise<ReleaseDto> {
        let url_ = this.baseUrl + "/api/Releasing/{carId}";
        if (carId === undefined || carId === null)
            throw new Error("The parameter 'carId' must be defined.");
        url_ = url_.replace("{carId}", encodeURIComponent("" + carId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRelease(_response);
        });
    }

    protected processDeleteRelease(response: Response): Promise<ReleaseDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReleaseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReleaseDto>(null as any);
    }
}

export class ReportsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getCarReport(accept_Language: AcceptLanguage61 | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Reports";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCarReport(_response);
        });
    }

    protected processGetCarReport(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UpComingEventsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param sortOrder (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getUpcomingEvents(startDate: Date | null | undefined, endDate: Date | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, sortOrder: string | undefined, accept_Language: AcceptLanguage62 | undefined): Promise<UpcomingEventVm> {
        let url_ = this.baseUrl + "/api/UpComingEvents?";
        if (startDate !== undefined && startDate !== null)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "sortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUpcomingEvents(_response);
        });
    }

    protected processGetUpcomingEvents(response: Response): Promise<UpcomingEventVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpcomingEventVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpcomingEventVm>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getUpcomingEventDetails(date: Date, accept_Language: AcceptLanguage63 | undefined): Promise<UpcomingEventVm> {
        let url_ = this.baseUrl + "/api/UpComingEvents/{date}";
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent(date ? "" + date.toISOString() : "null"));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUpcomingEventDetails(_response);
        });
    }

    protected processGetUpcomingEventDetails(response: Response): Promise<UpcomingEventVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpcomingEventVm.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpcomingEventVm>(null as any);
    }
}

export class UsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    getUsers(pageNumber: number | undefined, pageSize: number | undefined, accept_Language: AcceptLanguage64 | undefined): Promise<PaginatedListOfApplicationUserDto> {
        let url_ = this.baseUrl + "/api/Users?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: Response): Promise<PaginatedListOfApplicationUserDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfApplicationUserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfApplicationUserDto>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    createUser(accept_Language: AcceptLanguage65 | undefined, request: CreateUserRequest): Promise<string> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<string> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(item);
            }
            else {
                result400 = <any>null;
            }
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    getMe(accept_Language: AcceptLanguage66 | undefined): Promise<UserDetailsResponse> {
        let url_ = this.baseUrl + "/api/Users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMe(_response);
        });
    }

    protected processGetMe(response: Response): Promise<UserDetailsResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetailsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetailsResponse>(null as any);
    }
}

export class AuthenticationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    refreshToken(accept_Language: AcceptLanguage67 | undefined, refreshRequest: RefreshRequest): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Authentication/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: Response): Promise<AccessTokenResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @param changedEmail (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    confirmEmail(userId: string, code: string, changedEmail: string | null | undefined, accept_Language: AcceptLanguage68 | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Authentication/confirm-email?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined || code === null)
            throw new Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail !== undefined && changedEmail !== null)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmEmail(_response);
        });
    }

    protected processConfirmEmail(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    resendConfirmationEmail(accept_Language: AcceptLanguage69 | undefined, resendRequest: ResendConfirmationEmailRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/Authentication/resend-confirmation-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResendConfirmationEmail(_response);
        });
    }

    protected processResendConfirmationEmail(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    forgotPassword(accept_Language: AcceptLanguage70 | undefined, resetRequest: ForgotPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/Authentication/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param accept_Language (optional) Language preference for the response.
     */
    resetPassword(accept_Language: AcceptLanguage71 | undefined, resetRequest: ResetPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/Authentication/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param useCookies (optional) 
     * @param useSessionCookies (optional) 
     * @param accept_Language (optional) Language preference for the response.
     */
    postApiAuthenticationLogin(useCookies: boolean | null | undefined, useSessionCookies: boolean | null | undefined, accept_Language: AcceptLanguage72 | undefined, login: LoginRequest2): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Authentication/login?";
        if (useCookies !== undefined && useCookies !== null)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies !== undefined && useSessionCookies !== null)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostApiAuthenticationLogin(_response);
        });
    }

    protected processPostApiAuthenticationLogin(response: Response): Promise<AccessTokenResponse> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export class RegisterRequest implements IRegisterRequest {
    email?: string;
    password?: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email?: string;
    password?: string;
}

export class AccessTokenResponse implements IAccessTokenResponse {
    tokenType?: string;
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string;
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;
}

export class LoginRequest implements ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken?: string;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken?: string;
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email?: string;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email?: string;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email?: string;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email?: string;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email?: string;
    resetCode?: string;
    newPassword?: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email?: string;
    resetCode?: string;
    newPassword?: string;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey?: string;
    recoveryCodesLeft?: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled?: boolean;
    isMachineRemembered?: boolean;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey?: string;
    recoveryCodesLeft?: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled?: boolean;
    isMachineRemembered?: boolean;
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;
}

export class InfoResponse implements IInfoResponse {
    email?: string;
    isEmailConfirmed?: boolean;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email?: string;
    isEmailConfirmed?: boolean;
}

export class InfoRequest implements IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export class BrokerVm implements IBrokerVm {
    brokers?: BrokerDto[];
    totalCount?: number;

    constructor(data?: IBrokerVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["brokers"])) {
                this.brokers = [] as any;
                for (let item of _data["brokers"])
                    this.brokers!.push(BrokerDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BrokerVm {
        data = typeof data === 'object' ? data : {};
        let result = new BrokerVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.brokers)) {
            data["brokers"] = [];
            for (let item of this.brokers)
                data["brokers"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IBrokerVm {
    brokers?: BrokerDto[];
    totalCount?: number;
}

export class BrokerDto implements IBrokerDto {
    id?: string;
    userId?: string;
    userDetails?: UserDetailsResponse | undefined;
    cars?: CarBriefDto[];

    constructor(data?: IBrokerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userDetails = _data["userDetails"] ? UserDetailsResponse.fromJS(_data["userDetails"]) : <any>undefined;
            if (Array.isArray(_data["cars"])) {
                this.cars = [] as any;
                for (let item of _data["cars"])
                    this.cars!.push(CarBriefDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BrokerDto {
        data = typeof data === 'object' ? data : {};
        let result = new BrokerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userDetails"] = this.userDetails ? this.userDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.cars)) {
            data["cars"] = [];
            for (let item of this.cars)
                data["cars"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBrokerDto {
    id?: string;
    userId?: string;
    userDetails?: UserDetailsResponse | undefined;
    cars?: CarBriefDto[];
}

export class UserDetailsResponse implements IUserDetailsResponse {
    id?: string;
    userName?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    nationalId?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    profilePicture?: string;

    constructor(data?: IUserDetailsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.nationalId = _data["nationalId"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): UserDetailsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetailsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["nationalId"] = this.nationalId;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePicture"] = this.profilePicture;
        return data;
    }
}

export interface IUserDetailsResponse {
    id?: string;
    userName?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    nationalId?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    profilePicture?: string;
}

export class CarBriefDto implements ICarBriefDto {
    id?: string;
    makeName?: string;
    modelName?: string;
    year?: string;
    color?: string;
    inspectionCount?: number;
    documentCount?: number;
    status?: string;

    constructor(data?: ICarBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.makeName = _data["makeName"];
            this.modelName = _data["modelName"];
            this.year = _data["year"];
            this.color = _data["color"];
            this.inspectionCount = _data["inspectionCount"];
            this.documentCount = _data["documentCount"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CarBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["makeName"] = this.makeName;
        data["modelName"] = this.modelName;
        data["year"] = this.year;
        data["color"] = this.color;
        data["inspectionCount"] = this.inspectionCount;
        data["documentCount"] = this.documentCount;
        data["status"] = this.status;
        return data;
    }
}

export interface ICarBriefDto {
    id?: string;
    makeName?: string;
    modelName?: string;
    year?: string;
    color?: string;
    inspectionCount?: number;
    documentCount?: number;
    status?: string;
}

export class EditBrokerCommand implements IEditBrokerCommand {
    id?: string;
    name?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    nationalId?: string | undefined;
    profilePicture?: string | undefined;

    constructor(data?: IEditBrokerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.nationalId = _data["nationalId"];
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): EditBrokerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditBrokerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["username"] = this.username;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["nationalId"] = this.nationalId;
        data["profilePicture"] = this.profilePicture;
        return data;
    }
}

export interface IEditBrokerCommand {
    id?: string;
    name?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    nationalId?: string | undefined;
    profilePicture?: string | undefined;
}

export class CarVm implements ICarVm {
    cars?: CarBriefDto[];
    currentPage?: number;
    pageSize?: number;
    totalCount?: number;
    totalPages?: number;

    constructor(data?: ICarVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cars"])) {
                this.cars = [] as any;
                for (let item of _data["cars"])
                    this.cars!.push(CarBriefDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any): CarVm {
        data = typeof data === 'object' ? data : {};
        let result = new CarVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cars)) {
            data["cars"] = [];
            for (let item of this.cars)
                data["cars"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface ICarVm {
    cars?: CarBriefDto[];
    currentPage?: number;
    pageSize?: number;
    totalCount?: number;
    totalPages?: number;
}

export class CarDto implements ICarDto {
    id?: string;
    userId?: string;
    make?: string;
    model?: string;
    year?: string;
    color?: string;
    engineSerialNumber?: string;
    inspections?: InspectionBriefDto[];
    documents?: DocumentBriefDto[];
    owner?: OwnerDto;
    status?: string;
    isReleased?: boolean;
    release?: ReleaseDto;
    ownerDetails?: UserDetailsResponse;

    constructor(data?: ICarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.make = _data["make"];
            this.model = _data["model"];
            this.year = _data["year"];
            this.color = _data["color"];
            this.engineSerialNumber = _data["engineSerialNumber"];
            if (Array.isArray(_data["inspections"])) {
                this.inspections = [] as any;
                for (let item of _data["inspections"])
                    this.inspections!.push(InspectionBriefDto.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(DocumentBriefDto.fromJS(item));
            }
            this.owner = _data["owner"] ? OwnerDto.fromJS(_data["owner"]) : <any>undefined;
            this.status = _data["status"];
            this.isReleased = _data["isReleased"];
            this.release = _data["release"] ? ReleaseDto.fromJS(_data["release"]) : <any>undefined;
            this.ownerDetails = _data["ownerDetails"] ? UserDetailsResponse.fromJS(_data["ownerDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CarDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["make"] = this.make;
        data["model"] = this.model;
        data["year"] = this.year;
        data["color"] = this.color;
        data["engineSerialNumber"] = this.engineSerialNumber;
        if (Array.isArray(this.inspections)) {
            data["inspections"] = [];
            for (let item of this.inspections)
                data["inspections"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["isReleased"] = this.isReleased;
        data["release"] = this.release ? this.release.toJSON() : <any>undefined;
        data["ownerDetails"] = this.ownerDetails ? this.ownerDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICarDto {
    id?: string;
    userId?: string;
    make?: string;
    model?: string;
    year?: string;
    color?: string;
    engineSerialNumber?: string;
    inspections?: InspectionBriefDto[];
    documents?: DocumentBriefDto[];
    owner?: OwnerDto;
    status?: string;
    isReleased?: boolean;
    release?: ReleaseDto;
    ownerDetails?: UserDetailsResponse;
}

export class InspectionBriefDto implements IInspectionBriefDto {
    id?: string;
    text?: string;
    file?: string;

    constructor(data?: IInspectionBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): InspectionBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["file"] = this.file;
        return data;
    }
}

export interface IInspectionBriefDto {
    id?: string;
    text?: string;
    file?: string;
}

export class DocumentBriefDto implements IDocumentBriefDto {
    id?: string;
    title?: string;
    file?: string;

    constructor(data?: IDocumentBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): DocumentBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["file"] = this.file;
        return data;
    }
}

export interface IDocumentBriefDto {
    id?: string;
    title?: string;
    file?: string;
}

export class OwnerDto implements IOwnerDto {

    constructor(data?: IOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): OwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IOwnerDto {
}

export class ReleaseDto implements IReleaseDto {
    id?: string;
    releaseDate?: Date;
    car?: CarBriefDto;
    documents?: string[];

    constructor(data?: IReleaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>undefined;
            this.car = _data["car"] ? CarBriefDto.fromJS(_data["car"]) : <any>undefined;
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(item);
            }
        }
    }

    static fromJS(data: any): ReleaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReleaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["car"] = this.car ? this.car.toJSON() : <any>undefined;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item);
        }
        return data;
    }
}

export interface IReleaseDto {
    id?: string;
    releaseDate?: Date;
    car?: CarBriefDto;
    documents?: string[];
}

export class EditCarCommand implements IEditCarCommand {
    id?: string;
    engineSerialNumber?: string | undefined;
    modelId?: number | undefined;
    year?: number | undefined;
    colorId?: number | undefined;

    constructor(data?: IEditCarCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.engineSerialNumber = _data["engineSerialNumber"];
            this.modelId = _data["modelId"];
            this.year = _data["year"];
            this.colorId = _data["colorId"];
        }
    }

    static fromJS(data: any): EditCarCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditCarCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["engineSerialNumber"] = this.engineSerialNumber;
        data["modelId"] = this.modelId;
        data["year"] = this.year;
        data["colorId"] = this.colorId;
        return data;
    }
}

export interface IEditCarCommand {
    id?: string;
    engineSerialNumber?: string | undefined;
    modelId?: number | undefined;
    year?: number | undefined;
    colorId?: number | undefined;
}

export class PaginatedListOfDocumentDto implements IPaginatedListOfDocumentDto {
    items?: DocumentDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DocumentDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfDocumentDto {
    items?: DocumentDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class DocumentDto implements IDocumentDto {
    id?: string;
    title?: string;
    car?: CarBriefDto;
    file?: FileDto | undefined;

    constructor(data?: IDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.car = _data["car"] ? CarBriefDto.fromJS(_data["car"]) : <any>undefined;
            this.file = _data["file"] ? FileDto.fromJS(_data["file"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["car"] = this.car ? this.car.toJSON() : <any>undefined;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDocumentDto {
    id?: string;
    title?: string;
    car?: CarBriefDto;
    file?: FileDto | undefined;
}

export class FileDto implements IFileDto {
    fileName?: string;
    filePath?: string;
    originalFileName?: string;
    contentType?: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.originalFileName = _data["originalFileName"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["originalFileName"] = this.originalFileName;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IFileDto {
    fileName?: string;
    filePath?: string;
    originalFileName?: string;
    contentType?: string;
}

export class PaginatedListOfInspectionDto implements IPaginatedListOfInspectionDto {
    items?: InspectionDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfInspectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InspectionDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfInspectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfInspectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfInspectionDto {
    items?: InspectionDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class InspectionDto implements IInspectionDto {
    id?: string;
    text?: string;
    car?: CarBriefDto | undefined;
    file?: FileDto;

    constructor(data?: IInspectionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.car = _data["car"] ? CarBriefDto.fromJS(_data["car"]) : <any>undefined;
            this.file = _data["file"] ? FileDto.fromJS(_data["file"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InspectionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["car"] = this.car ? this.car.toJSON() : <any>undefined;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInspectionDto {
    id?: string;
    text?: string;
    car?: CarBriefDto | undefined;
    file?: FileDto;
}

export class ColorVm implements IColorVm {
    colors?: ColorDto[];

    constructor(data?: IColorVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["colors"])) {
                this.colors = [] as any;
                for (let item of _data["colors"])
                    this.colors!.push(ColorDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ColorVm {
        data = typeof data === 'object' ? data : {};
        let result = new ColorVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.colors)) {
            data["colors"] = [];
            for (let item of this.colors)
                data["colors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IColorVm {
    colors?: ColorDto[];
}

export class ColorDto implements IColorDto {
    id?: number;
    localizedName?: string;

    constructor(data?: IColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localizedName = _data["localizedName"];
        }
    }

    static fromJS(data: any): ColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localizedName"] = this.localizedName;
        return data;
    }
}

export interface IColorDto {
    id?: number;
    localizedName?: string;
}

export class MakeVm implements IMakeVm {
    makes?: MakeDto[];
    totalCount?: number;

    constructor(data?: IMakeVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["makes"])) {
                this.makes = [] as any;
                for (let item of _data["makes"])
                    this.makes!.push(MakeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MakeVm {
        data = typeof data === 'object' ? data : {};
        let result = new MakeVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.makes)) {
            data["makes"] = [];
            for (let item of this.makes)
                data["makes"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }
}

export interface IMakeVm {
    makes?: MakeDto[];
    totalCount?: number;
}

export class MakeDto implements IMakeDto {
    id?: number;
    name?: string;
    models?: ModelDto[];

    constructor(data?: IMakeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["models"])) {
                this.models = [] as any;
                for (let item of _data["models"])
                    this.models!.push(ModelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MakeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MakeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.models)) {
            data["models"] = [];
            for (let item of this.models)
                data["models"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMakeDto {
    id?: number;
    name?: string;
    models?: ModelDto[];
}

export class ModelDto implements IModelDto {
    id?: number;
    name?: string;
    make?: MakeDto;

    constructor(data?: IModelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.make = _data["make"] ? MakeDto.fromJS(_data["make"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ModelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["make"] = this.make ? this.make.toJSON() : <any>undefined;
        return data;
    }
}

export interface IModelDto {
    id?: number;
    name?: string;
    make?: MakeDto;
}

export class ModelVm implements IModelVm {
    models?: ModelDto[];
    totalCount?: number;
    pageSize?: number;
    totalPages?: number;
    totalItems?: number;

    constructor(data?: IModelVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["models"])) {
                this.models = [] as any;
                for (let item of _data["models"])
                    this.models!.push(ModelDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): ModelVm {
        data = typeof data === 'object' ? data : {};
        let result = new ModelVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.models)) {
            data["models"] = [];
            for (let item of this.models)
                data["models"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IModelVm {
    models?: ModelDto[];
    totalCount?: number;
    pageSize?: number;
    totalPages?: number;
    totalItems?: number;
}

export class OverallDto implements IOverallDto {
    enteredCarsToday?: number;
    enteredCarsThisMonth?: number;
    enteredCarsThisYear?: number;
    totalCars?: number;
    topBrokers?: BrokerDto[];

    constructor(data?: IOverallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enteredCarsToday = _data["enteredCarsToday"];
            this.enteredCarsThisMonth = _data["enteredCarsThisMonth"];
            this.enteredCarsThisYear = _data["enteredCarsThisYear"];
            this.totalCars = _data["totalCars"];
            if (Array.isArray(_data["topBrokers"])) {
                this.topBrokers = [] as any;
                for (let item of _data["topBrokers"])
                    this.topBrokers!.push(BrokerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OverallDto {
        data = typeof data === 'object' ? data : {};
        let result = new OverallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enteredCarsToday"] = this.enteredCarsToday;
        data["enteredCarsThisMonth"] = this.enteredCarsThisMonth;
        data["enteredCarsThisYear"] = this.enteredCarsThisYear;
        data["totalCars"] = this.totalCars;
        if (Array.isArray(this.topBrokers)) {
            data["topBrokers"] = [];
            for (let item of this.topBrokers)
                data["topBrokers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOverallDto {
    enteredCarsToday?: number;
    enteredCarsThisMonth?: number;
    enteredCarsThisYear?: number;
    totalCars?: number;
    topBrokers?: BrokerDto[];
}

export class RoleVm implements IRoleVm {
    roles?: RoleDto[];

    constructor(data?: IRoleVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleVm {
        data = typeof data === 'object' ? data : {};
        let result = new RoleVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRoleVm {
    roles?: RoleDto[];
}

export class RoleDto implements IRoleDto {
    id?: string;
    name?: string;
    description?: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IRoleDto {
    id?: string;
    name?: string;
    description?: string | undefined;
}

export class OrderVm implements IOrderVm {
    list?: PaginatedListOfCarBriefDto;

    constructor(data?: IOrderVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.list = _data["list"] ? PaginatedListOfCarBriefDto.fromJS(_data["list"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderVm {
        data = typeof data === 'object' ? data : {};
        let result = new OrderVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["list"] = this.list ? this.list.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrderVm {
    list?: PaginatedListOfCarBriefDto;
}

export class PaginatedListOfCarBriefDto implements IPaginatedListOfCarBriefDto {
    items?: CarBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCarBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CarBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCarBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCarBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCarBriefDto {
    items?: CarBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class OrderDto implements IOrderDto {

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IOrderDto {
}

export class PaginatedListOfParkingSlotDto implements IPaginatedListOfParkingSlotDto {
    items?: ParkingSlotDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfParkingSlotDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ParkingSlotDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfParkingSlotDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfParkingSlotDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfParkingSlotDto {
    items?: ParkingSlotDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ParkingSlotDto implements IParkingSlotDto {
    id?: number;
    title?: string;
    description?: string;
    isAvailable?: boolean;
    capacity?: number;
    cars?: CarBriefDto[];

    constructor(data?: IParkingSlotDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.isAvailable = _data["isAvailable"];
            this.capacity = _data["capacity"];
            if (Array.isArray(_data["cars"])) {
                this.cars = [] as any;
                for (let item of _data["cars"])
                    this.cars!.push(CarBriefDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParkingSlotDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParkingSlotDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["isAvailable"] = this.isAvailable;
        data["capacity"] = this.capacity;
        if (Array.isArray(this.cars)) {
            data["cars"] = [];
            for (let item of this.cars)
                data["cars"].push(item.toJSON());
        }
        return data;
    }
}

export interface IParkingSlotDto {
    id?: number;
    title?: string;
    description?: string;
    isAvailable?: boolean;
    capacity?: number;
    cars?: CarBriefDto[];
}

export class EditParkingSlotCommand implements IEditParkingSlotCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    capacity?: number | undefined;

    constructor(data?: IEditParkingSlotCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.capacity = _data["capacity"];
        }
    }

    static fromJS(data: any): EditParkingSlotCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditParkingSlotCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["capacity"] = this.capacity;
        return data;
    }
}

export interface IEditParkingSlotCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    capacity?: number | undefined;
}

export class ReleaseVm implements IReleaseVm {
    releases?: ReleaseDto[];

    constructor(data?: IReleaseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["releases"])) {
                this.releases = [] as any;
                for (let item of _data["releases"])
                    this.releases!.push(ReleaseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReleaseVm {
        data = typeof data === 'object' ? data : {};
        let result = new ReleaseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.releases)) {
            data["releases"] = [];
            for (let item of this.releases)
                data["releases"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReleaseVm {
    releases?: ReleaseDto[];
}

export class EditReleaseCommand implements IEditReleaseCommand {
    carId?: string;

    constructor(data?: IEditReleaseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.carId = _data["carId"];
        }
    }

    static fromJS(data: any): EditReleaseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EditReleaseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["carId"] = this.carId;
        return data;
    }
}

export interface IEditReleaseCommand {
    carId?: string;
}

export class UpcomingEventVm implements IUpcomingEventVm {
    upcomingEvents?: UpcomingEventDto[];

    constructor(data?: IUpcomingEventVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upcomingEvents"])) {
                this.upcomingEvents = [] as any;
                for (let item of _data["upcomingEvents"])
                    this.upcomingEvents!.push(UpcomingEventDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpcomingEventVm {
        data = typeof data === 'object' ? data : {};
        let result = new UpcomingEventVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upcomingEvents)) {
            data["upcomingEvents"] = [];
            for (let item of this.upcomingEvents)
                data["upcomingEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpcomingEventVm {
    upcomingEvents?: UpcomingEventDto[];
}

export class UpcomingEventDto implements IUpcomingEventDto {
    car?: CarBriefDto;
    type?: string;
    date?: Date;

    constructor(data?: IUpcomingEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.car = _data["car"] ? CarBriefDto.fromJS(_data["car"]) : <any>undefined;
            this.type = _data["type"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpcomingEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpcomingEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["car"] = this.car ? this.car.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpcomingEventDto {
    car?: CarBriefDto;
    type?: string;
    date?: Date;
}

export class PaginatedListOfApplicationUserDto implements IPaginatedListOfApplicationUserDto {
    items?: ApplicationUserDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfApplicationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationUserDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfApplicationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfApplicationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfApplicationUserDto {
    items?: ApplicationUserDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ApplicationUserDto implements IApplicationUserDto {
    id?: number;
    userName?: string;
    fullName?: string;
    avatarUrl?: string;

    constructor(data?: IApplicationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.avatarUrl = _data["avatarUrl"];
        }
    }

    static fromJS(data: any): ApplicationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["avatarUrl"] = this.avatarUrl;
        return data;
    }
}

export interface IApplicationUserDto {
    id?: number;
    userName?: string;
    fullName?: string;
    avatarUrl?: string;
}

export class CreateUserRequest implements ICreateUserRequest {
    userName?: string;
    password?: string;
    firstName?: string;
    lastName?: string | undefined;
    email?: string;
    phoneNumber?: string;
    personalPhoto?: string | undefined;

    constructor(data?: ICreateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.personalPhoto = _data["personalPhoto"];
        }
    }

    static fromJS(data: any): CreateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["personalPhoto"] = this.personalPhoto;
        return data;
    }
}

export interface ICreateUserRequest {
    userName?: string;
    password?: string;
    firstName?: string;
    lastName?: string | undefined;
    email?: string;
    phoneNumber?: string;
    personalPhoto?: string | undefined;
}

export class LoginRequest2 implements ILoginRequest2 {
    userName?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    constructor(data?: ILoginRequest2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest2 {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest2 {
    userName?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export enum AcceptLanguage {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage2 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage3 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage4 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage5 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage6 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage7 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage8 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage9 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage10 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage11 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage12 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage13 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage14 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage15 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage16 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage17 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage18 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage19 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage20 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage21 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage22 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage23 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage24 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage25 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage26 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage27 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage28 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage29 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage30 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage31 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage32 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage33 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage34 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage35 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage36 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage37 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage38 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage39 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage40 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage41 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage42 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage43 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage44 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage45 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage46 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage47 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage48 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage49 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage50 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage51 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage52 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage53 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage54 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage55 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage56 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage57 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage58 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage59 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage60 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage61 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage62 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage63 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage64 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage65 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage66 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage67 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage68 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage69 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage70 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage71 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export enum AcceptLanguage72 {
    ArEG = "ar-EG",
    EnUS = "en-US",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}